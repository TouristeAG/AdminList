package com.eventmanager.app

import android.content.Context
import android.content.res.Configuration
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import java.util.*
import androidx.compose.foundation.background
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.icons.filled.Group
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.PlayArrow
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Build
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material.icons.filled.Sync
import androidx.compose.material3.*
import com.eventmanager.app.ui.components.QRScannerDialog
import com.eventmanager.app.ui.components.VolunteerBenefitsPanel
import com.eventmanager.app.ui.scaling.ResolutionScaler
import com.eventmanager.app.data.models.VolunteerBenefitStatus
import com.eventmanager.app.data.models.Benefit
import com.eventmanager.app.data.models.Guest
import com.eventmanager.app.data.models.Volunteer
import com.eventmanager.app.data.models.Job
import androidx.compose.runtime.*
import kotlinx.coroutines.launch
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.foundation.Canvas
import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.togetherWith
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import kotlin.random.Random
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.PI
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.lifecycle.viewmodel.compose.viewModel
import com.eventmanager.app.data.database.EventManagerDatabase
import com.eventmanager.app.data.repository.EventManagerRepository
import com.eventmanager.app.data.sync.GoogleSheetsService
import com.eventmanager.app.ui.screens.BenefitsScreen
import com.eventmanager.app.ui.screens.GuestListScreen
import com.eventmanager.app.ui.screens.JobTrackingScreen
import com.eventmanager.app.ui.screens.JobTypeManagementScreen
import com.eventmanager.app.ui.screens.SettingsScreen
import com.eventmanager.app.ui.screens.VenueManagementScreen
import com.eventmanager.app.ui.screens.VolunteerScreen
import com.eventmanager.app.ui.theme.EventManagerTheme
import com.eventmanager.app.ui.theme.ThemeMode
import com.eventmanager.app.ui.viewmodel.EventManagerViewModel
import com.eventmanager.app.data.sync.SettingsManager
import com.eventmanager.app.ui.utils.*
import com.eventmanager.app.ui.components.AnimatedBackground
import com.eventmanager.app.R
import androidx.compose.ui.text.style.TextAlign

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Apply language setting
        applyLanguageSettings()
        
        // Apply resolution scaling
        applyResolutionScaling()
        
        setContent {
            val settingsManager = SettingsManager(this)
            val themeMode = ThemeMode.fromString(settingsManager.getThemeMode())
            
            EventManagerTheme(themeMode = themeMode) {
                EventManagerApp()
            }
        }
    }
    
    override fun attachBaseContext(newBase: Context?) {
        super.attachBaseContext(applyLanguageToContext(applyResolutionScalingToContext(newBase)))
    }
    
    private fun applyLanguageSettings() {
        val settingsManager = SettingsManager(this)
        val language = settingsManager.getLanguage()
        
        val locale = Locale(language)
        Locale.setDefault(locale)
        
        val config = Configuration(resources.configuration)
        config.setLocale(locale)
        
        resources.updateConfiguration(config, resources.displayMetrics)
    }
    
    private fun applyResolutionScaling() {
        val settingsManager = SettingsManager(this)
        val resolutionScale = settingsManager.getResolutionScale()
        
        // Always apply resolution scaling, even if it's 1.0f (to reset any previous scaling)
        val originalMetrics = resources.displayMetrics
        val originalDensity = originalMetrics.density
        val originalScaledDensity = originalMetrics.scaledDensity
        
        // Modify density to achieve resolution scaling effect
        originalMetrics.density = originalDensity / resolutionScale
        originalMetrics.scaledDensity = originalScaledDensity / resolutionScale
        originalMetrics.densityDpi = (originalMetrics.density * 160).toInt()
    }
    
    private fun applyLanguageToContext(context: Context?): Context? {
        if (context == null) return null
        
        val settingsManager = SettingsManager(context)
        val language = settingsManager.getLanguage()
        
        val locale = Locale(language)
        val config = Configuration(context.resources.configuration)
        config.setLocale(locale)
        
        return context.createConfigurationContext(config)
    }
    
    private fun applyResolutionScalingToContext(context: Context?): Context? {
        if (context == null) return null
        
        val settingsManager = SettingsManager(context)
        val resolutionScale = settingsManager.getResolutionScale()
        
        // Always apply resolution scaling, even if it's 1.0f (to reset any previous scaling)
        return ResolutionScaler.applyResolutionScaling(context, resolutionScale)
    }
}

@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)
@Composable
fun EventManagerApp() {
    var showWelcome by remember { mutableStateOf(true) }
    var selectedTab by remember { mutableStateOf(0) }
    var previousTab by remember { mutableStateOf(0) }
    val appContext = LocalContext.current
    val settingsManager = remember { SettingsManager(appContext) }
    val pageAnimationsEnabled = settingsManager.isPageAnimationsEnabled()
    var showJobTypeManagement by remember { mutableStateOf(false) }
    var showVenueManagement by remember { mutableStateOf(false) }
    var showQRScanner by remember { mutableStateOf(false) }
    var showVolunteerBenefits by remember { mutableStateOf<Volunteer?>(null) }

    if (showWelcome) {
        WelcomeScreen(onStartManaging = { showWelcome = false })
    } else {
        // Initialize database and repository
        val database = EventManagerDatabase.getDatabase(LocalContext.current)
        val repository = EventManagerRepository(
            database.guestDao(),
            database.volunteerDao(),
            database.jobDao(),
            database.jobTypeConfigDao(),
            database.venueDao()
        )
        val context = LocalContext.current
        val googleSheetsService = GoogleSheetsService(context)
        val viewModel: EventManagerViewModel = viewModel {
            EventManagerViewModel(repository, googleSheetsService, context)
        }
        
        // On app launch: download-only sync to avoid overwriting remote data
        LaunchedEffect(Unit) {
            println("App started - triggering initial download-only full sync...")
            viewModel.performFullSync()
        }

        Scaffold(
            bottomBar = {
                // Modern bottom navigation bar with horizontal scrolling on phones
                if (!isTablet()) {
                    // Horizontal scrolling navigation for phones
                    val scrollState = rememberScrollState()
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .horizontalScroll(scrollState)
                            .padding(horizontal = 8.dp, vertical = 4.dp)
                            .background(
                                color = MaterialTheme.colorScheme.surface,
                                shape = RoundedCornerShape(16.dp)
                            )
                            .padding(8.dp),
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        val context = LocalContext.current
                        val tabs = listOf(
                            context.getString(R.string.nav_dashboard) to Icons.Default.Home,
                            context.getString(R.string.nav_guests) to Icons.Default.Person,
                            context.getString(R.string.nav_volunteers) to Icons.Default.Group,
                            context.getString(R.string.nav_shifts) to Icons.Default.Build,
                            context.getString(R.string.nav_benefits) to Icons.Default.Star,
                            context.getString(R.string.nav_settings) to Icons.Default.Settings
                        )
                        
                        tabs.forEachIndexed { index, (title, icon) ->
                            Card(
                                modifier = Modifier
                                    .width(100.dp)
                                    .clickable {
                                        if (selectedTab != index) {
                                            println("Tab changed from $selectedTab to $index - triggering targeted sync")
                                            // Sync the page we're leaving and the page we're entering
                                            when (selectedTab) {
                                                0 -> viewModel.syncGuestsOnly() // Dashboard -> Guest List
                                                1 -> viewModel.syncVolunteersOnly() // Guest List -> Volunteers
                                                2 -> viewModel.syncJobsOnly() // Volunteers -> Jobs
                                                3 -> viewModel.syncJobsOnly() // Jobs -> Benefits
                                            }
                                            when (index) {
                                                0 -> viewModel.syncGuestsOnly() // Enter Dashboard
                                                1 -> viewModel.syncVolunteersOnly() // Enter Guest List
                                                2 -> viewModel.syncVolunteersOnly() // Enter Volunteers
                                                3 -> viewModel.syncJobsOnly() // Enter Jobs
                                                4 -> viewModel.syncJobsOnly() // Enter Benefits
                                            }
                                        }
                                        previousTab = selectedTab
                                        selectedTab = index
                                    },
                                shape = RoundedCornerShape(12.dp),
                                colors = CardDefaults.cardColors(
                                    containerColor = if (selectedTab == index)
                                        MaterialTheme.colorScheme.primaryContainer
                                    else
                                        MaterialTheme.colorScheme.surfaceVariant
                                ),
                                elevation = CardDefaults.cardElevation(
                                    defaultElevation = if (selectedTab == index) 4.dp else 1.dp
                                )
                            ) {
                                Column(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(horizontal = 8.dp, vertical = 8.dp),
                                    horizontalAlignment = Alignment.CenterHorizontally,
                                    verticalArrangement = Arrangement.Center
                                ) {
                                    val scale by animateFloatAsState(
                                        targetValue = if (selectedTab == index && pageAnimationsEnabled) 1.1f else 1.0f,
                                        animationSpec = if (pageAnimationsEnabled) spring(stiffness = Spring.StiffnessMedium) else spring(stiffness = Spring.StiffnessHigh),
                                        label = "bottom_icon_scale"
                                    )
                                    Icon(
                                        icon,
                                        contentDescription = title,
                                        modifier = Modifier.size(20.dp).graphicsLayer(scaleX = scale, scaleY = scale),
                                        tint = if (selectedTab == index) 
                                            MaterialTheme.colorScheme.onPrimaryContainer 
                                        else 
                                            MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                    Spacer(modifier = Modifier.height(4.dp))
                                    Text(
                                        text = title,
                                        style = MaterialTheme.typography.labelSmall.copy(fontSize = 10.sp),
                                        color = if (selectedTab == index) 
                                            MaterialTheme.colorScheme.onPrimaryContainer 
                                        else 
                                            MaterialTheme.colorScheme.onSurfaceVariant,
                                        maxLines = 1,
                                        overflow = TextOverflow.Ellipsis
                                    )
                                }
                            }
                        }
                    }
                } else {
                    // Regular navigation bar for tablets
                    NavigationBar(
                        containerColor = MaterialTheme.colorScheme.surface,
                        contentColor = MaterialTheme.colorScheme.onSurface,
                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)
                    ) {
                        val context = LocalContext.current
                        val tabs = listOf(
                            context.getString(R.string.nav_dashboard) to Icons.Default.Home,
                            context.getString(R.string.nav_guests) to Icons.Default.Person,
                            context.getString(R.string.nav_volunteers) to Icons.Default.Group,
                            context.getString(R.string.nav_shifts) to Icons.Default.Build,
                            context.getString(R.string.nav_benefits) to Icons.Default.Star,
                            context.getString(R.string.nav_settings) to Icons.Default.Settings
                        )
                        
                        tabs.forEachIndexed { index, (title, icon) ->
                            NavigationBarItem(
                                selected = selectedTab == index,
                                onClick = {
                                    if (selectedTab != index) {
                                        println("Tab changed from $selectedTab to $index - triggering targeted sync")
                                        // Sync the page we're leaving and the page we're entering
                                        when (selectedTab) {
                                            0 -> viewModel.syncGuestsOnly() // Dashboard -> Guest List
                                            1 -> viewModel.syncVolunteersOnly() // Guest List -> Volunteers
                                            2 -> viewModel.syncJobsOnly() // Volunteers -> Jobs
                                            3 -> viewModel.syncJobsOnly() // Jobs -> Benefits
                                        }
                                        when (index) {
                                            0 -> viewModel.syncGuestsOnly() // Enter Dashboard
                                            1 -> viewModel.syncVolunteersOnly() // Enter Guest List
                                            2 -> viewModel.syncVolunteersOnly() // Enter Volunteers
                                            3 -> viewModel.syncJobsOnly() // Enter Jobs
                                            4 -> viewModel.syncJobsOnly() // Enter Benefits
                                        }
                                    }
                                    previousTab = selectedTab
                                    selectedTab = index
                                },
                                icon = {
                                    val scale by animateFloatAsState(
                                        targetValue = if (selectedTab == index && pageAnimationsEnabled) 1.1f else 1.0f,
                                        animationSpec = if (pageAnimationsEnabled) spring(stiffness = Spring.StiffnessMedium) else spring(stiffness = Spring.StiffnessHigh),
                                        label = "bottom_icon_scale_tablet"
                                    )
                                    Icon(
                                        icon,
                                        contentDescription = title,
                                        modifier = Modifier.size(24.dp).graphicsLayer(scaleX = scale, scaleY = scale)
                                    )
                                },
                                label = {
                                    Text(
                                        text = title,
                                        style = MaterialTheme.typography.labelSmall
                                    )
                                }
                            )
                        }
                    }
                }
            }
        ) { innerPadding ->
            // Main content with modern padding, sync widget, and swipe gestures
            val isPhone = !isTablet()
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding)
                    .padding(
                        horizontal = if (isPhone) 8.dp else 16.dp, 
                        vertical = if (isPhone) 4.dp else 8.dp
                    )
            ) {
                // Animated background
                AnimatedBackground(
                    enabled = settingsManager.isAnimatedBackgroundEnabled()
                )
                
                // Main content
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .pointerInput(Unit) {
                        var startX = 0f
                        var hasSwiped = false
                        detectDragGestures(
                            onDragStart = { offset ->
                                startX = offset.x
                                hasSwiped = false
                            },
                            onDragEnd = { 
                                // Reset startX after gesture completes
                                startX = 0f
                                hasSwiped = false
                            },
                            onDrag = { change, _ ->
                                // Only enable swipe gestures on phones
                                if (isPhone) {
                                    val deltaX = change.position.x - startX
                                    val threshold = 100f
                                    
                                    if (!hasSwiped) {
                                        when {
                                            deltaX > threshold -> {
                                            // Swipe right - go to previous tab
                                            if (selectedTab > 0) {
                                                    previousTab = selectedTab
                                                    selectedTab = selectedTab - 1
                                                    hasSwiped = true
                                            }
                                            }
                                            deltaX < -threshold -> {
                                            // Swipe left - go to next tab
                                            if (selectedTab < 5) {
                                                    previousTab = selectedTab
                                                    selectedTab = selectedTab + 1
                                                    hasSwiped = true
                                            }
                                            }
                                        }
                                    }
                                }
                            }
                        )
                    }
            ) {
                // Tab Content with directional slide animation
                val goingLeft = selectedTab > previousTab
                if (pageAnimationsEnabled) {
                    AnimatedContent(
                        targetState = selectedTab,
                        transitionSpec = {
                            val duration = 280
                            val enter = slideInHorizontally(
                                animationSpec = tween(durationMillis = duration, easing = FastOutSlowInEasing),
                                initialOffsetX = { fullWidth -> if (goingLeft) fullWidth else -fullWidth }
                            ) + fadeIn(animationSpec = tween(durationMillis = duration))
                            val exit = slideOutHorizontally(
                                animationSpec = tween(durationMillis = duration, easing = FastOutSlowInEasing),
                                targetOffsetX = { fullWidth -> if (goingLeft) -fullWidth / 2 else fullWidth / 2 }
                            ) + fadeOut(animationSpec = tween(durationMillis = duration))
                            enter togetherWith exit
                        },
                        label = "page_transition"
                    ) { tab ->
                        when {
                            showJobTypeManagement -> JobTypeManagementScreenWithViewModel(viewModel) {
                                println("Exiting Job Type Management - triggering job types sync")
                                viewModel.syncJobTypesOnly()
                                showJobTypeManagement = false
                            }
                            showVenueManagement -> VenueManagementScreenWithViewModel(viewModel) {
                                println("Exiting Venue Management")
                                showVenueManagement = false
                            }
                            tab == 0 -> DashboardScreenWithViewModel(viewModel)
                            tab == 1 -> GuestListScreenWithViewModel(viewModel)
                            tab == 2 -> VolunteerScreenWithViewModel(viewModel)
                            tab == 3 -> JobTrackingScreenWithViewModel(viewModel)
                            tab == 4 -> BenefitsScreenWithViewModel(viewModel)
                            tab == 5 -> SettingsScreen(
                                viewModel = viewModel,
                                onNavigateToJobTypeManagement = { 
                                    println("Navigating to Job Type Management - triggering job types sync")
                                    viewModel.syncJobTypesOnly()
                                    showJobTypeManagement = true 
                                },
                                onNavigateToVenueManagement = { 
                                    println("Navigating to Venue Management")
                                    showVenueManagement = true 
                                }
                            )
                        }
                    }
                } else {
                    when {
                        showJobTypeManagement -> JobTypeManagementScreenWithViewModel(viewModel) {
                            println("Exiting Job Type Management - triggering job types sync")
                            viewModel.syncJobTypesOnly()
                            showJobTypeManagement = false
                        }
                        showVenueManagement -> VenueManagementScreenWithViewModel(viewModel) {
                            println("Exiting Venue Management")
                            showVenueManagement = false
                        }
                        selectedTab == 0 -> DashboardScreenWithViewModel(viewModel)
                        selectedTab == 1 -> GuestListScreenWithViewModel(viewModel)
                        selectedTab == 2 -> VolunteerScreenWithViewModel(viewModel)
                        selectedTab == 3 -> JobTrackingScreenWithViewModel(viewModel)
                        selectedTab == 4 -> BenefitsScreenWithViewModel(viewModel)
                        selectedTab == 5 -> SettingsScreen(
                            viewModel = viewModel,
                            onNavigateToJobTypeManagement = { 
                                println("Navigating to Job Type Management - triggering job types sync")
                                viewModel.syncJobTypesOnly()
                                showJobTypeManagement = true 
                            },
                            onNavigateToVenueManagement = { 
                                println("Navigating to Venue Management")
                                showVenueManagement = true 
                            }
                        )
                    }
                }
                
                    // QR Scanner button in bottom left corner above navigation bar
                    QRScannerButton(
                        onClick = { showQRScanner = true },
                        modifier = Modifier
                            .align(Alignment.BottomStart)
                            .padding(bottom = 8.dp, start = 8.dp)
                    )
                    
                    // Sync status widget in bottom right corner above navigation bar
                    SyncStatusWidget(
                        viewModel = viewModel,
                        modifier = Modifier
                            .align(Alignment.BottomEnd)
                            .padding(bottom = 8.dp, end = 8.dp)
                    )
                }
            }
        }
        
        // QR Scanner Dialog
        if (showQRScanner) {
            QRScannerDialog(
                onDismiss = { showQRScanner = false },
                onVolunteerFound = { volunteer ->
                    showVolunteerBenefits = volunteer
                    showQRScanner = false
                },
                volunteers = viewModel.volunteers.value
            )
        }
        
        // Volunteer Benefits Panel
        showVolunteerBenefits?.let { volunteer ->
            val volunteerBenefitStatus = com.eventmanager.app.data.models.BenefitCalculator.calculateVolunteerBenefitStatus(
                volunteer = volunteer,
                jobs = viewModel.jobs.value,
                jobTypeConfigs = viewModel.jobTypeConfigs.value
            )

            androidx.compose.ui.window.Dialog(onDismissRequest = { showVolunteerBenefits = null }) {
                VolunteerBenefitsPanel(
                    volunteer = volunteer,
                    volunteerBenefitStatus = volunteerBenefitStatus,
                    volunteerJobs = viewModel.jobs.value.filter { it.volunteerId == volunteer.id },
                    venues = viewModel.venues.value,
                    onClose = { showVolunteerBenefits = null }
                )
            }
        }
    }
}

// Sync Status Widget
@Composable
fun SyncStatusWidget(
viewModel: EventManagerViewModel,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    val lastSyncTime by viewModel.lastSyncTime.collectAsState()
    val isSyncing by viewModel.isSyncing.collectAsState()
    
    // Interaction source for press feedback
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()
    
    // Animate scale on press
    val scale by animateFloatAsState(
        targetValue = if (isPressed && !isSyncing) 0.95f else 1f,
        animationSpec = tween(100),
        label = "sync_pill_scale"
    )
    
    Card(
        modifier = modifier
            .padding(4.dp)
            .clickable(
                enabled = !isSyncing,
                interactionSource = interactionSource,
                indication = null,
                onClick = {
                    // Trigger manual sync when clicked
                    viewModel.performFullSync()
                }
            ),
        shape = RoundedCornerShape(20.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (isSyncing) 
                MaterialTheme.colorScheme.primaryContainer 
            else 
                MaterialTheme.colorScheme.surfaceVariant
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = if (isPressed && !isSyncing) 4.dp else 2.dp
        )
    ) {
        Row(
            modifier = Modifier
                .padding(horizontal = 12.dp, vertical = 6.dp)
                .scale(scale),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            if (isSyncing) {
                CircularProgressIndicator(
                    modifier = Modifier.size(16.dp),
                    strokeWidth = 2.dp,
                    color = MaterialTheme.colorScheme.primary
                )
                Text(
                    text = context.getString(R.string.syncing),
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
            } else {
                Icon(
                    imageVector = if (lastSyncTime > 0) Icons.Default.Refresh else Icons.Default.Sync,
                    contentDescription = "Tap to sync",
                    modifier = Modifier.size(16.dp),
                    tint = if (lastSyncTime > 0) 
                        MaterialTheme.colorScheme.primary 
                    else 
                        MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    text = if (lastSyncTime > 0) {
                        val timeAgo = System.currentTimeMillis() - lastSyncTime
                        when {
                            timeAgo < 60000 -> context.getString(R.string.synced_now)
                            timeAgo < 3600000 -> context.getString(R.string.synced_minutes_ago, timeAgo / 60000)
                            timeAgo < 86400000 -> context.getString(R.string.synced_hours_ago, timeAgo / 3600000)
                            else -> context.getString(R.string.synced_days_ago, timeAgo / 86400000)
                        }
                    } else {
                        context.getString(R.string.never_synced)
                    },
                    style = MaterialTheme.typography.labelSmall,
                    color = if (lastSyncTime > 0) 
                        MaterialTheme.colorScheme.onPrimaryContainer 
                    else 
                        MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

// QR Scanner Button Widget
@Composable
fun QRScannerButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    // Interaction source for press feedback
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()
    
    // Animate scale on press
    val scale by animateFloatAsState(
        targetValue = if (isPressed) 0.95f else 1f,
        animationSpec = tween(100),
        label = "qr_button_scale"
    )
    
    Card(
        modifier = modifier
            .padding(4.dp)
            .clickable(
                interactionSource = interactionSource,
                indication = null,
                onClick = onClick
            ),
        shape = RoundedCornerShape(20.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = if (isPressed) 4.dp else 2.dp
        )
    ) {
        Box(
            modifier = Modifier
                .padding(12.dp)
                .scale(scale),
            contentAlignment = Alignment.Center
        ) {
            Image(
                painter = painterResource(id = R.drawable.qrscan_icon),
                contentDescription = "Scan QR Code",
                modifier = Modifier.size(20.dp),
                colorFilter = ColorFilter.tint(
                    MaterialTheme.colorScheme.onSurfaceVariant
                )
            )
        }
    }
}

// Dashboard Screen
@Composable
fun DashboardScreenWithViewModel(viewModel: EventManagerViewModel) {
    val guests by viewModel.guests.collectAsState()
    val volunteers by viewModel.volunteers.collectAsState()
    val jobs by viewModel.jobs.collectAsState()
    val jobTypeConfigs by viewModel.jobTypeConfigs.collectAsState()
    val isSyncing by viewModel.isSyncing.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    val context = LocalContext.current
    val settingsManager = remember { SettingsManager(context) }
    
    // Trigger targeted sync when screen loads
    LaunchedEffect(Unit) {
        println("Dashboard screen loaded - triggering targeted sync")
        viewModel.syncGuestsOnly()
    }

    DashboardScreen(
        guests = guests,
        volunteers = volunteers,
        jobs = jobs,
        isSyncing = isSyncing,
        lastSyncTime = settingsManager.getLastSyncTime()
    )
}

@Composable
fun DashboardScreen(
    guests: List<Guest>,
    volunteers: List<Volunteer>,
    jobs: List<Job>,
    isSyncing: Boolean = false,
    lastSyncTime: Long = 0L
) {
    val context = LocalContext.current
    val isCompact = isCompactScreen()
    val isPhone = !isTablet()
    val responsivePadding = if (isPhone) getPhonePortraitPadding() else getResponsivePadding()
    val responsiveSpacing = if (isPhone) getPhonePortraitSpacing() else getResponsiveSpacing()
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(responsivePadding)
    ) {
        // Modern header
        Card(
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(if (isPhone) 12.dp else 16.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer
            ),
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
        ) {
            Column(
                modifier = Modifier.padding(if (isPhone) 12.dp else 20.dp)
            ) {
                Text(
                    text = context.getString(R.string.dashboard_title),
                    style = if (isPhone) getPhonePortraitTypography() else getResponsiveTypography(),
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
                
                Spacer(modifier = Modifier.height(if (isPhone) 2.dp else 4.dp))
                
                Text(
                    text = if (isPhone) context.getString(R.string.dashboard_subtitle_phone) else context.getString(R.string.dashboard_subtitle_tablet),
                    style = if (isPhone) getPhonePortraitBodyTypography() else getResponsiveBodyTypography(),
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }
        }
        
        Spacer(modifier = Modifier.height(if (isPhone) 16.dp else 24.dp))
        
        // Calculate statistics
        val permanentGuests = guests.count { !it.isVolunteerBenefit }
        val volunteerBenefitGuests = guests.count { it.isVolunteerBenefit }
        val totalVolunteers = volunteers.size
        val activeVolunteersCount = volunteers.count { it.isActive }
        val inactiveVolunteersCount = volunteers.count { !it.isActive }
        val totalInvites = guests.sumOf { it.invitations }
        val totalPeople = permanentGuests + volunteerBenefitGuests + totalVolunteers + totalInvites
        
        // Calculate past month jobs
        val currentTime = System.currentTimeMillis()
        val oneMonthAgo = currentTime - (30L * 24 * 60 * 60 * 1000)
        val jobsPastMonth = jobs.count { it.date >= oneMonthAgo }
        
        // Calculate free drinks offered today
        val todayStart = System.currentTimeMillis().let { time ->
            val cal = java.util.Calendar.getInstance()
            cal.timeInMillis = time
            cal.set(java.util.Calendar.HOUR_OF_DAY, 0)
            cal.set(java.util.Calendar.MINUTE, 0)
            cal.set(java.util.Calendar.SECOND, 0)
            cal.set(java.util.Calendar.MILLISECOND, 0)
            cal.timeInMillis
        }
        val todayEnd = todayStart + (24 * 60 * 60 * 1000)
        val todayJobs = jobs.filter { it.date in todayStart until todayEnd }
        
        // Statistics Grid - 2 columns
        Column(
            verticalArrangement = Arrangement.spacedBy(if (isPhone) 12.dp else 16.dp)
        ) {
            // Row 1: Permanent Guests, Total Volunteers
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(if (isPhone) 12.dp else 16.dp)
            ) {
                StatCardV2(
                    title = context.getString(R.string.permanent_guests),
                    value = permanentGuests.toString(),
                    icon = Icons.Default.Person,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
                
                StatCardV2(
                    title = context.getString(R.string.volunteers_total),
                    value = totalVolunteers.toString(),
                    icon = Icons.Default.Group,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
            }
            
            // Row 2: +1 Invites, Total People
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(if (isPhone) 12.dp else 16.dp)
            ) {
                StatCardV2(
                    title = context.getString(R.string.plus_one_invites),
                    value = totalInvites.toString(),
                    icon = Icons.Default.PlayArrow,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
                
                StatCardV2(
                    title = context.getString(R.string.total_people),
                    value = totalPeople.toString(),
                    icon = Icons.Default.Star,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
            }
            
            // Row 3: Shifts Past Month, Active Volunteers
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(if (isPhone) 12.dp else 16.dp)
            ) {
                StatCardV2(
                    title = context.getString(R.string.shifts_past_month),
                    value = jobsPastMonth.toString(),
                    icon = Icons.Default.Build,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
                
                StatCardV2(
                    title = context.getString(R.string.active_volunteers),
                    value = activeVolunteersCount.toString(),
                    icon = Icons.Default.CheckCircle,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
            }
            
            // Row 4: Inactive Volunteers, Free Drinks Today
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(if (isPhone) 12.dp else 16.dp)
            ) {
                StatCardV2(
                    title = context.getString(R.string.inactive_volunteers),
                    value = inactiveVolunteersCount.toString(),
                    icon = Icons.Default.Warning,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
                
                StatCardV2(
                    title = context.getString(R.string.free_drinks_today),
                    value = "0", // TODO: Calculate from volunteer benefits
                    icon = Icons.Default.Star,
                    modifier = Modifier.weight(1f),
                    isPhone = isPhone
                )
            }
        }
        
        Spacer(modifier = Modifier.height(if (isPhone) 16.dp else 24.dp))
        
        // Recent Activity with modern design
        Card(
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(if (isPhone) 12.dp else 16.dp),
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
        ) {
            Column(
                modifier = Modifier.padding(if (isPhone) 12.dp else 20.dp)
            ) {
                Text(
                    text = context.getString(R.string.recent_activity),
                    style = if (isPhone) MaterialTheme.typography.titleSmall else if (isCompact) MaterialTheme.typography.titleMedium else getResponsiveTitleTypography(),
                    fontWeight = FontWeight.SemiBold
                )
                
                Spacer(modifier = Modifier.height(if (isPhone) 8.dp else 12.dp))
                
                if (guests.isNotEmpty()) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = if (isPhone) 2.dp else 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Person,
                            contentDescription = null,
                            modifier = Modifier.size(if (isPhone) 14.dp else 16.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(if (isPhone) 6.dp else 8.dp))
                        Text(
                            text = if (isPhone) context.getString(R.string.latest_guest_phone, guests.last().name) else context.getString(R.string.latest_guest_tablet, guests.last().name),
                            style = if (isPhone) getPhonePortraitBodyTypography() else if (isCompact) MaterialTheme.typography.bodySmall else getResponsiveBodyTypography()
                        )
                    }
                }
                
                if (volunteers.isNotEmpty()) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = if (isPhone) 2.dp else 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Group,
                            contentDescription = null,
                            modifier = Modifier.size(if (isPhone) 14.dp else 16.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(if (isPhone) 6.dp else 8.dp))
                        Text(
                            text = if (isPhone) context.getString(R.string.latest_volunteer_phone, volunteers.last().name) else context.getString(R.string.latest_volunteer_tablet, volunteers.last().name),
                            style = if (isPhone) getPhonePortraitBodyTypography() else if (isCompact) MaterialTheme.typography.bodySmall else getResponsiveBodyTypography()
                        )
                    }
                }
                
                if (jobs.isNotEmpty()) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = if (isPhone) 2.dp else 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Build,
                            contentDescription = null,
                            modifier = Modifier.size(if (isPhone) 14.dp else 16.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(if (isPhone) 6.dp else 8.dp))
                        Text(
                            text = if (isPhone) context.getString(R.string.latest_job_phone, jobs.last().jobTypeName) else context.getString(R.string.latest_job_tablet, jobs.last().jobTypeName),
                            style = if (isPhone) getPhonePortraitBodyTypography() else if (isCompact) MaterialTheme.typography.bodySmall else getResponsiveBodyTypography()
                        )
                    }
                }
            }
        }
        
        // Bottom padding to ensure content is not cut off by navigation bar or sync widget
        Spacer(modifier = Modifier.height(if (isPhone) 80.dp else 100.dp))
    }
}

@Composable
fun StatCard(
    title: String,
    value: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    modifier: Modifier = Modifier
) {
    val isCompact = isCompactScreen()
    val isPhone = !isTablet()
    val responsivePadding = getResponsivePadding()
    val responsiveIconSize = getResponsiveIconSize()
    
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(if (isPhone) 12.dp else 16.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(if (isPhone) 12.dp else 20.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Icon with background circle
            Box(
                modifier = Modifier
                    .size(if (isPhone) 40.dp else if (isCompact) 48.dp else 56.dp)
                    .background(
                        color = MaterialTheme.colorScheme.primaryContainer,
                        shape = CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    modifier = Modifier.size(if (isPhone) 20.dp else if (isCompact) 24.dp else responsiveIconSize),
                    tint = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }
            
            Spacer(modifier = Modifier.height(if (isPhone) 8.dp else 12.dp))
            
            Text(
                text = value,
                style = if (isPhone) MaterialTheme.typography.titleLarge else if (isCompact) MaterialTheme.typography.headlineSmall else MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(if (isPhone) 2.dp else 4.dp))
            
            Text(
                text = title,
                style = if (isPhone) getPhonePortraitBodyTypography() else if (isCompact) MaterialTheme.typography.bodySmall else MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
fun StatCardV2(
    title: String,
    value: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    modifier: Modifier = Modifier,
    isPhone: Boolean = !isTablet()
) {
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(if (isPhone) 12.dp else 16.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
        ),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 2.dp,
            pressedElevation = 6.dp
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(if (isPhone) 14.dp else 16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Icon with animated background
            Box(
                modifier = Modifier
                    .size(if (isPhone) 36.dp else 44.dp)
                    .background(
                        color = MaterialTheme.colorScheme.primaryContainer,
                        shape = RoundedCornerShape(if (isPhone) 8.dp else 12.dp)
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    modifier = Modifier.size(if (isPhone) 18.dp else 22.dp),
                    tint = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }
            
            Spacer(modifier = Modifier.height(if (isPhone) 8.dp else 10.dp))
            
            // Large value text
            Text(
                text = value,
                style = if (isPhone) MaterialTheme.typography.headlineSmall else MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.ExtraBold,
                color = MaterialTheme.colorScheme.onSurface,
                textAlign = TextAlign.Center
            )
            
            Spacer(modifier = Modifier.height(if (isPhone) 4.dp else 6.dp))
            
            // Title text - wrapped to handle long titles
            Text(
                text = title,
                style = if (isPhone) MaterialTheme.typography.labelSmall else MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

// Wrapper composables that connect screens to ViewModel
@Composable
fun GuestListScreenWithViewModel(viewModel: EventManagerViewModel) {
    val guests by viewModel.guests.collectAsState()
    val volunteers by viewModel.volunteers.collectAsState()
    val jobs by viewModel.jobs.collectAsState()
    val jobTypeConfigs by viewModel.jobTypeConfigs.collectAsState()
    val venues by viewModel.venues.collectAsState()
    val isSyncing by viewModel.isSyncing.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    val context = LocalContext.current
    val settingsManager = remember { SettingsManager(context) }
    
    // Trigger targeted sync when screen loads
    LaunchedEffect(Unit) {
        println("Guest List screen loaded - triggering targeted sync")
        viewModel.syncGuestsOnly()
    }
    
    GuestListScreen(
        guests = guests,
        volunteers = volunteers,
        jobs = jobs,
        jobTypeConfigs = jobTypeConfigs,
        venues = venues,
        isSyncing = isSyncing,
        lastSyncTime = settingsManager.getLastSyncTime(),
        onAddGuest = { 
            coroutineScope.launch { 
                try {
                    viewModel.addGuest(it)
                } catch (e: Exception) {
                    // Exception is already handled in ViewModel and shown in syncError
                    println("Guest addition failed: ${e.message}")
                }
            } 
        },
        onUpdateGuest = { 
            coroutineScope.launch { 
                try {
                    viewModel.updateGuest(it)
                } catch (e: Exception) {
                    println("Guest update failed: ${e.message}")
                }
            } 
        },
        onDeleteGuest = { 
            coroutineScope.launch { 
                try {
                    viewModel.deleteGuest(it)
                } catch (e: Exception) {
                    println("Guest deletion failed: ${e.message}")
                }
            } 
        }
    )
}

@Composable
fun VolunteerScreenWithViewModel(viewModel: EventManagerViewModel) {
    val volunteers by viewModel.volunteers.collectAsState()
    val jobs by viewModel.jobs.collectAsState()
    val venues by viewModel.venues.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    
    // Trigger sync when screen loads
    LaunchedEffect(Unit) {
        println("Volunteer screen loaded - triggering targeted sync")
        viewModel.syncVolunteersOnly()
    }
    
    VolunteerScreen(
        volunteers = volunteers,
        volunteerJobs = jobs,
        venues = venues,
        onAddVolunteer = { 
            coroutineScope.launch { 
                try {
                    viewModel.addVolunteer(it)
                } catch (e: Exception) {
                    println("Volunteer addition failed: ${e.message}")
                }
            } 
        },
        onUpdateVolunteer = { 
            coroutineScope.launch { 
                try {
                    viewModel.updateVolunteer(it)
                } catch (e: Exception) {
                    println("Volunteer update failed: ${e.message}")
                }
            } 
        },
        onDeleteVolunteer = { 
            coroutineScope.launch { 
                try {
                    viewModel.deleteVolunteer(it)
                } catch (e: Exception) {
                    println("Volunteer deletion failed: ${e.message}")
                }
            } 
        }
    )
}

@Composable
fun JobTrackingScreenWithViewModel(viewModel: EventManagerViewModel) {
    val jobs by viewModel.jobs.collectAsState()
    val volunteers by viewModel.volunteers.collectAsState()
    val jobTypeConfigs by viewModel.jobTypeConfigs.collectAsState()
    val venues by viewModel.venues.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    
    // Trigger sync when screen loads
    LaunchedEffect(Unit) {
        println("Job Tracking screen loaded - triggering targeted sync")
        viewModel.syncJobsOnly()
    }

    JobTrackingScreen(
        jobs = jobs,
        volunteers = volunteers,
        jobTypeConfigs = jobTypeConfigs,
        venues = venues,
        onAddJob = { 
            coroutineScope.launch { 
                try {
                    viewModel.addJob(it)
                } catch (e: Exception) {
                    println("Job addition failed: ${e.message}")
                }
            }
        },
        onUpdateJob = { 
            coroutineScope.launch { 
                try {
                    viewModel.updateJob(it)
                } catch (e: Exception) {
                    println("Job update failed: ${e.message}")
                }
            }
        },
        onDeleteJob = { 
            coroutineScope.launch { 
                try {
                    viewModel.deleteJob(it)
                } catch (e: Exception) {
                    println("Job deletion failed: ${e.message}")
                }
            }
        }
    )
}

@Composable
fun BenefitsScreenWithViewModel(viewModel: EventManagerViewModel) {
    val volunteers by viewModel.volunteers.collectAsState()
    val jobs by viewModel.jobs.collectAsState()
    val jobTypeConfigs by viewModel.jobTypeConfigs.collectAsState()
    
    // Trigger sync when screen loads
    LaunchedEffect(Unit) {
        println("Benefits screen loaded - triggering targeted sync")
        viewModel.syncJobsOnly()
    }
    
    BenefitsScreen(
        volunteers = volunteers,
        jobs = jobs,
        jobTypeConfigs = jobTypeConfigs
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WelcomeScreen(onStartManaging: () -> Unit) {
    val context = LocalContext.current
    Scaffold { innerPadding ->
        // Full-bleed launch screen with custom background and bottom CTA
        BoxWithConstraints(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .background(Color(0xFFFFF9EA))
        ) {
            // Background arches
            ArchedCirclesBackground()

            // Center content: CNL logo
            val context = LocalContext.current
            val logoResId = remember {
                context.resources.getIdentifier("cnl", "drawable", context.packageName)
            }
            val isLandscape = maxWidth > maxHeight

            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 24.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                if (logoResId != 0) {
                    Image(
                        painter = painterResource(id = logoResId),
                        contentDescription = "CNL Logo",
                        modifier = Modifier
                            .fillMaxWidth(if (isLandscape) 0.25f else 0.65f)
                            .aspectRatio(1f)
                    )
                } else {
                    Text(
                        text = "CNL",
                        style = if (isLandscape) MaterialTheme.typography.titleLarge else MaterialTheme.typography.displayLarge,
                        fontWeight = FontWeight.ExtraBold,
                        color = Color(0xFF2E1E2E)
                    )
                }
            }

            // Bottom Start button
            Button(
                onClick = onStartManaging,
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .padding(horizontal = 24.dp, vertical = 24.dp)
                    .fillMaxWidth(if (isLandscape) 0.6f else 1f)
                    .height(if (isLandscape) 48.dp else 64.dp),
                shape = RoundedCornerShape(if (isLandscape) 24.dp else 32.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF8E72C6),
                    contentColor = Color.White
                )
            ) {
                Text(
                    text = context.getString(R.string.start_admin),
                    style = if (isLandscape) MaterialTheme.typography.titleMedium else MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Black,
                    color = Color.White
                )
            }
        }
    }
}

// Data class outside composable to avoid LiveEdit conflicts
private data class ArchCircleParam(val fx: Float, val fy: Float, val theta: Float, val color: Color)

@Composable
private fun ArchedCirclesBackground() {
    // Prepare randomized circle layout once per app run
    val circles = remember {
        val rnd = Random(System.nanoTime())
        val count = 50 // a lot more circles
        List(count) { i ->
            val fx = rnd.nextFloat() // 0..1 normalized
            val fy = rnd.nextFloat()
            val theta = rnd.nextFloat() * 2f * PI.toFloat()
            val color = if (i % 2 == 0) Color(0xFFDCD6E1) else Color(0xFFD0BEDF)
            ArchCircleParam(fx, fy, theta, color)
        }
    }

    // Subtle perpetual drift animation
    val infinite = rememberInfiniteTransition(label = "arches")
    val phase1 by infinite.animateFloat(
        initialValue = 0f,
        targetValue = 2f * PI.toFloat(),
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 25000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "phase1"
    )
    val phase2 by infinite.animateFloat(
        initialValue = 0f,
        targetValue = 2f * PI.toFloat(),
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 30000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "phase2"
    )

    // Draw very large circles so only sweeping arches are visible, adapting to phone/tablet/orientation
    Canvas(modifier = Modifier.fillMaxSize()) {
        val maxDim = maxOf(size.width, size.height)
        val stroke = (maxDim * 0.012f).coerceIn(6f, 18f)

        // Same radius for all, centers distributed and animated
        val circleRadius = maxDim * 1.2f
        val amp = maxDim * 0.025f // subtle drift amplitude

        // Allow centers anywhere across and slightly beyond the whole screen
        val startX = -0.5f * size.width
        val spanX = size.width * 2.0f
        val startY = -0.5f * size.height
        val spanY = size.height * 2.0f

        circles.forEachIndexed { index, p ->
            val driftX = amp * cos(phase1 + p.theta)
            val driftY = amp * sin(phase2 + p.theta)
            val cx = startX + p.fx * spanX + driftX
            val cy = startY + p.fy * spanY + driftY
            drawCircle(
                color = p.color,
                radius = circleRadius,
                center = Offset(cx, cy),
                style = Stroke(width = stroke, cap = StrokeCap.Round)
            )
        }
    }
}

// Job Type Management Screen
@Composable
fun JobTypeManagementScreenWithViewModel(
    viewModel: EventManagerViewModel,
    _onBack: () -> Unit
) {
    val jobTypeConfigs by viewModel.jobTypeConfigs.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    
    // Trigger sync when screen loads
    LaunchedEffect(Unit) {
        println("Job Type Management screen loaded - triggering targeted sync")
        viewModel.syncJobTypesOnly()
    }
    
    JobTypeManagementScreen(
        jobTypeConfigs = jobTypeConfigs,
        onAddJobTypeConfig = { config ->
            coroutineScope.launch {
                try {
                    viewModel.addJobTypeConfig(config)
                } catch (e: Exception) {
                    println("Job type config addition failed: ${e.message}")
                }
            }
        },
        onUpdateJobTypeConfig = { config ->
            coroutineScope.launch {
                try {
                    viewModel.updateJobTypeConfig(config)
                } catch (e: Exception) {
                    println("Job type config update failed: ${e.message}")
                }
            }
        },
        onDeleteJobTypeConfig = { config ->
            coroutineScope.launch {
                try {
                    viewModel.deleteJobTypeConfig(config)
                } catch (e: Exception) {
                    println("Job type config deletion failed: ${e.message}")
                }
            }
        },
        onUpdateJobTypeConfigStatus = { id, isActive ->
            coroutineScope.launch {
                try {
                    val config = viewModel.jobTypeConfigs.value.find { it.id == id }
                    if (config != null) {
                        viewModel.updateJobTypeConfig(config.copy(isActive = isActive))
                    }
                } catch (e: Exception) {
                    println("Job type config status update failed: ${e.message}")
                }
            }
        },
        onBack = _onBack
    )
}

@Composable
fun VenueManagementScreenWithViewModel(
    viewModel: EventManagerViewModel,
    _onBack: () -> Unit
) {
    val venues by viewModel.venues.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    
    VenueManagementScreen(
        venues = venues,
        onAddVenue = { venue ->
            coroutineScope.launch {
                try {
                    viewModel.addVenue(venue)
                } catch (e: Exception) {
                    println("Venue addition failed: ${e.message}")
                }
            }
        },
        onUpdateVenue = { venue ->
            coroutineScope.launch {
                try {
                    viewModel.updateVenue(venue)
                } catch (e: Exception) {
                    println("Venue update failed: ${e.message}")
                }
            }
        },
        onDeleteVenue = { venue ->
            coroutineScope.launch {
                try {
                    viewModel.deleteVenue(venue)
                } catch (e: Exception) {
                    println("Venue deletion failed: ${e.message}")
                }
            }
        },
        onUpdateVenueStatus = { id, isActive ->
            coroutineScope.launch {
                try {
                    viewModel.updateVenueStatus(id, isActive)
                } catch (e: Exception) {
                    println("Venue status update failed: ${e.message}")
                }
            }
        },
        onBack = _onBack
    )
}
